package com.k_int.accesscontrol.core.sql;

import com.k_int.accesscontrol.core.policyengine.PolicyEngineException;

import java.util.regex.Pattern;

/**
 * Defines the contract for all policy subquery generators used by the access-control
 * policy engine.
 *
 * <p>A {@code PolicySubquery} produces an {@link AccessControlSql} object that
 * encapsulates an SQL predicate (or subquery fragment) along with its bound parameter
 * values and associated {@link AccessControlSqlType}s. These fragments are combined by
 * the policy engine to enforce policy-based filtering when retrieving protected
 * resources.</p>
 *
 * <p>Implementations of this interface are responsible for translating a specific
 * policy linkage mechanism—such as acquisition-unit membership, KI grants,
 * hierarchical ownership rules, or any other policy structure—into SQL that can be
 * applied within a larger query. All generated SQL must use positional JDBC
 * placeholders ({@code ?}) for parameter binding.</p>
 * <hr />
 * <strong>SQL Safety</strong>
 * <p>
 * To mitigate SQL injection risks, implementations should rely on
 * {@link #sqlSafe(String, String)} to validate all identifiers that are interpolated
 * directly into the SQL string (e.g., aliases, column names). Dynamic values such as
 * resource IDs <em>must</em> be bound as parameters rather than concatenated.

 * Implementations can also rely on {@link #uuidSafe(String, String)} to validate that a given parameter is a valid
 * UUIDv4 String.
 * </p>
 */
public interface PolicySubquery {
  /**
   * Generates an SQL predicate or subquery fragment using the provided contextual
   * parameters.
   *
   * <p>The returned {@link AccessControlSql} includes:</p>
   * <ul>
   *   <li>the rendered SQL string with {@code ?} placeholders,</li>
   *   <li>the ordered parameter list, and</li>
   *   <li>the parameter types.</li>
   * </ul>
   *
   * <p>Implementations are expected to:</p>
   * <ul>
   *   <li>validate all interpolated identifiers using {@link #sqlSafe(String, String)},</li>
   *   <li>use only {@code ?} for parameter binding, and</li>
   *   <li>preserve the ordering of parameters exactly as required by the SQL string.</li>
   * </ul>
   *
   * @param parameters structured metadata describing aliases, column names,
   *                   resource identifiers, resource class, and other contextual
   *                   values required to generate the SQL
   * @return an {@link AccessControlSql} containing the SQL fragment and its bound
   *         parameters
   */
  AccessControlSql getSql(PolicySubqueryParameters parameters);

  /**
   * A regular expression used to validate SQL identifiers that may be interpolated
   * directly into a query string.
   *
   * <p>The following patterns are permitted:</p>
   * <ul>
   *   <li>{@code ?} (parameter placeholder),</li>
   *   <li>standard SQL/Hibernate identifiers, e.g. {@code table.column} or {@code alias},</li>
   *   <li>Hibernate-style alias parameters in braces, e.g. {@code {alias}.field}.</li>
   * </ul>
   *
   * <p>This pattern prevents embedding unsafe characters or injection payloads into
   * SQL fragments generated by a subquery implementation.</p>
   */
  Pattern SAFE_SQL =
    Pattern.compile("^(\\?|[A-Za-z_][A-Za-z0-9_$.]*|\\{[A-Za-z_][A-Za-z0-9_$.]*}(?:\\.[A-Za-z_][A-Za-z0-9_$.]*)?)$");

  /**
   * Regular expression for validating UUIDv4 identifiers.
   *
   * <p>Used by subqueries that require UUID parameters (e.g., resource IDs). Ensures
   * that UUIDs injected into SQL or used as parameters conform strictly to expected
   * formatting.</p>
   */
  Pattern SAFE_UUID4 =
    Pattern.compile("[0-9a-fA-F]{8}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{12}");

  /**
   * Validates that the provided SQL identifier is safe to interpolate directly into an
   * SQL fragment.
   *
   * <p>If the identifier fails validation, this method throws a
   * {@link PolicyEngineException} with
   * {@link PolicyEngineException#INVALID_QUERY_PARAMETERS}, preventing unsafe SQL
   * construction.</p>
   *
   * <p>This method should be used for:</p>
   * <ul>
   *   <li>aliases,</li>
   *   <li>column names,</li>
   *   <li>table names,</li>
   *   <li>Hibernate alias expressions such as {@code {alias}.column}.</li>
   * </ul>
   *
   * @param id    the identifier to validate
   * @param label descriptive label used in exception messages
   * @return the validated identifier
   * @throws PolicyEngineException if the identifier contains unsafe characters or is null
   */
  static String sqlSafe(String id, String label) {
    if (id == null || !SAFE_SQL.matcher(id).matches()) {
      throw new PolicyEngineException("Unacceptable SQL injected for " + label + ": " + id,
        PolicyEngineException.INVALID_QUERY_PARAMETERS);
    }
    return id;
  }

  /**
   * Validates that the provided identifier is a valid UUIDv4 string.
   *
   * <p>Subqueries that receive externally-sourced UUIDs (such as resource IDs or
   * policy IDs) may use this method to perform strict validation prior to parameter
   * binding. Prevents malformed or hostile UUID-like values from being passed into
   * SQL queries.</p>
   *
   * @param id    the UUID string to validate
   * @param label descriptive label used in exception messages
   * @return the validated UUID
   * @throws PolicyEngineException if the UUID fails format validation or is null
   */
  static String uuidSafe(String id, String label) {
    if (id == null || !SAFE_UUID4.matcher(id).matches()) {
      throw new PolicyEngineException("Unacceptable UUID injected for " + label + ": " + id,
        PolicyEngineException.INVALID_QUERY_PARAMETERS);
    }
    return id;
  }
}
