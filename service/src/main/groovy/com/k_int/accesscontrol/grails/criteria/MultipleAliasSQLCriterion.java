package com.k_int.accesscontrol.grails.criteria;

import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import org.apache.commons.lang3.ArrayUtils;
import org.hibernate.Criteria;
import org.hibernate.HibernateException;
import org.hibernate.criterion.CriteriaQuery;
import org.hibernate.criterion.SQLCriterion;
import org.hibernate.internal.util.StringHelper;
import org.hibernate.internal.util.collections.ArrayHelper;

import org.hibernate.type.*;

import java.util.Arrays;


/** NOTE -- This is an unfortunate side effect of us needing to continue to use the deprecated HibernateCriteriaBuilder for our doTheLookup. <br/>
 * Adapted from <a href="https://stackoverflow.com/a/19378756">StackOverflow</a>
 * <hr/>
 *
 * We require multiple aliases to be available when an ownership chain longer than 1 exists.
 * Say SubscriptionAgreement -> Entitlement -> OrderLine. When fetching OrderLines we need to be able to reference
 * SubscriptionAgreement id since the policy will be against that.
 */
@Slf4j
public class MultipleAliasSQLCriterion extends SQLCriterion {

  /**
   * Convenience container class to pack the info necessary to replace the alias      generated at construction time
   * with the alias generated by hibernate
   */
  @Getter
  public static final class SubCriteriaAliasContainer
  {
    /** The alias assigned at construction time
     */
    private final String alias;

    /** The criteria constructed with the specified alias
     */
    private final Criteria subCriteria;

    /**
     * @param aAlias
     *            - the alias assigned by criteria construction time
     * @param aSubCriteria
     *            - the criteria
     */
    public SubCriteriaAliasContainer(final String aAlias, final Criteria aSubCriteria)
    {
      this.alias = aAlias;
      this.subCriteria = aSubCriteria;
    }
  }

  private final SubCriteriaAliasContainer[] subCriteriaAliases;

  /**
   * This method constructs a new native SQL restriction with support for multiple aliases
   *
   * @param sql
   *            - the native SQL restriction
   * @param aSubCriteriaAliases
   *            - the aliases
   */
  public MultipleAliasSQLCriterion(final String sql, final SubCriteriaAliasContainer... aSubCriteriaAliases)
  {
    super(sql, ArrayHelper.EMPTY_OBJECT_ARRAY, ArrayHelper.EMPTY_TYPE_ARRAY);

    this.subCriteriaAliases = aSubCriteriaAliases;
  }

  /**
   * Default toStringType for values that are not explicitly typed.
   * This is a workaround to ensure that if no types are provided, we assume all values are strings.
   * In a real application, you would want to provide more specific types based on your use case.
   *
   * @param values The values to be used in the SQL criterion
   * @return An array of StringType for each value
   */
  private static Type[] defaultToStringType(Object[] values) {
    Type[] types = new Type[values.length];
    Arrays.fill(types, StringType.INSTANCE); // Use StringType.INSTANCE for Hibernate types

    return types;
  }

  public MultipleAliasSQLCriterion(final String sql, Object[] values, final SubCriteriaAliasContainer... aSubCriteriaAliases)
  {
    // If no types passed, assume all values are strings
    super(sql, values, defaultToStringType(values));

    this.subCriteriaAliases = aSubCriteriaAliases;
  }

  // If one of our values is not a string, we need to pass the types explicitly -- we may end up needing a mapping from accesscontrol types to Hibernate types :(
  public MultipleAliasSQLCriterion(final String sql, Object[] values, Type[] types, final SubCriteriaAliasContainer... aSubCriteriaAliases)
  {
    super(sql, values, types);

    this.subCriteriaAliases = aSubCriteriaAliases;
  }

  @Override
  public String toSqlString(Criteria criteria, CriteriaQuery criteriaQuery) throws HibernateException {
    String sql = super.toSqlString(criteria, criteriaQuery);

    if (!ArrayUtils.isEmpty(this.subCriteriaAliases)) {
      for (final SubCriteriaAliasContainer subCriteriaAlias : this.subCriteriaAliases) {
      String alias = subCriteriaAlias.alias;
        // Cheat the system by appending "." to the end of alias. This will force it to lookup by alias name
        //  not just the criteria which will have a different hash if totalCount is called
        String actualAlias = criteriaQuery.getSQLAlias(subCriteriaAlias.getSubCriteria(), alias + ".");
        sql = StringHelper.replace(sql, subCriteriaAlias.getAlias(), actualAlias);
      }
    }
    return sql;
  }

}